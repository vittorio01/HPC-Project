/* Parallel MPI Version of the BAT Algorithm v1.0 */
// This current version only minimizes the function

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "data.h"
#include "bat.h"
#include "tools.h"

// -- Bat Properties --
#define N_BATS 20
#define N_ITER 10   // Max Optimization Iterations
#define F_MIN 0.0
#define F_MAX 100.0
#define A_0 1.0     // Initial Loudness
#define R_0 0.0     // Initial Pulse Rate
#define ALPHA 0.9   // Loudness Cooling Factor
#define BETA_MIN 0.0
#define BETA_MAX 1.0
#define GAMMA 0.9   // Pulse Rate Warming Factor
#define V_BOUND 10.0  // Max Initial Random Velocity

// -- Function Properties --
// space is gonna be from [-POS_BOUND, POS_BOUND] x [-POS_BOUND, POS_BOUND], so a square
#define POS_BOUND 1000.0  // Max X, Y coordinates
#define DIM 2         // Problem Dimension

int main(int argc, char** argv) {

    // Required data structures
    Bat ** bat_array = malloc(N_BATS * sizeof(Bat));
    Vector * fitness = NULL;
    initVector(&fitness_vec, N_BATS);

    int best_index = 0; // index of bat with best fitness
    double best_fitness; // value of fitness of best bat

    // Create N Bats instances, each with random initial position and velocity
    for (int i = 0; i < N_BATS; i++) {
        bat_array[i] = malloc(sizeof(Bat));
        batRandom(bat_array[i], POS_BOUND, V_BOUND, 0, A_0, R_0);

        // evaluate initial fitness
        fitness->data[i] = evaluateFitness2D(bat_array[i]->pos);
    }

    // Evaluate initial global fitness, position with first best fitness is recorded
    best_index = minOfVec(fitness);
    best_fitness = fitness->data[best_index];

    // Perform N_ITER iteration of the optimization loop
    for (int i = 0; i < N_ITER; i++) {
        // Calculate average loudness
        double sum_A = 0;
        double avg_A = 0;
        for (int j = 0; j < N_BATS; j++) {
            sum_A = sum_A + bat_array[j]->a;
        }
        avg_A = sum_A / N_BATS;

        // Iterate through bats
        for (int j = 0; j < N_BATS; j++) {

            // -- GLOBAL SEARCH --
            // Choose beta for each bat
            double beta = random_uniform(BETA_MIN, BETA_MAX);
            // frequency update
            bat_array[j]->freq = F_MIN + (F_MAX - F_MIN) * beta;
            // velocity update (for each component)
            // ex. V = V{j} + (X{best_bat} - X{j}) * f{j}
            // x - component
            bat_array[j]->v->data[0] = bat_array[j]->v->data[0] +
                                       (bat_array[best_index]->pos->data[0] - bat_array[j]->pos->data[0]) *
                                        bat_array[j]->freq;
            // y - component
            bat_array[j]->v->data[1] = bat_array[j]->v->data[1] +
                                       (bat_array[best_index]->pos->data[1] - bat_array[j]->pos->data[1]) *
                                        bat_array[j]->freq;

            // Position update of the BAT
            Vector * candidate_pos = NULL;
            initVector(&candidate_pos, DIM);
            if (candidate_pos != NULL) {
                // start from current position
                copyVector(bat_array[j]->pos, candidate_pos);

                // apply global move
                candidate_pos->data[0] += bat_array[j]->v->data[0]; // x
                candidate_pos->data[1] += bat_array[j]->v->data[1]; // y

                // clamp candidate within bounds usign a tem Bat wrapper
                Bat temp_bat;
                temp_bat.pos = candidate_pos;
                batCheckPos(&temp_bat, POS_BOUND);
            }

            // -- LOCAL SEARCH (RANDOM WALK) --
            // - Generate a random number between 0 and 1, if that is greater than bat pulse rate, then perform local search
            double rand_local_search = random_uniform(0.0, 1.0);

            if (rand_local_search > bat_array[j]->r && candidate_pos != NULL) {
               double epsilon = random_uniform(-1.0 , 1.0);

               // you can use here either avg_A over all bats or bat[j]->A, experiment with both!
               candidate_pos->data[0] = bat_array[best_index]->pos->data[0]
                                        + epsilon * bat_array[j]->a;
               candidate_pos->data[1] = bat_array[best_index]->pos->data[1]
                                        + epsilon * bat_array[j]->a;

               // Clamp again after local search
               Bat temp_bat;
               temp_bat.pos = candidate_pos;
               batCheckPos(&temp_bat, POS_BOUND);
            }

            // -- EVALUATION AND ACCEPTANCE --
            // Evaluate the new solution generated by flying randomly
            double new_fitness = evaluateFitness2D(candidate_pos);

            double rand_acceptance = random_uniform(0.0, 1.0);
            if (rand_acceptance < bat_array[j]->a && new_fitness < best_fitness) {
                // Accept the new solution: copy candidate int bat j
                copyVector(candidate_pos, bat_array[j]->pos);
                fitness->data[j] = new_fitness;

                // Update loudness and Pulse Rate
                bat_array[j]->a = ALPHA * bat_array[j]->a;
                bat_array[j]->r = R_0 * (1.0 - exp(-GAMMA) * (double)i); // TODO why i here??

                // Update global best
                if (new_fitness < best_fitness) { // TODO new_fitness is already better than best fitness, why check again??
                    best_fitness = new_fitness;
                    best_index = j;
                }
            }

            destroyVector(&candidate_pos);

        }

    }

    // REMEMBER TO FREE EVERYTHING IN HERE

    return 0;
}
